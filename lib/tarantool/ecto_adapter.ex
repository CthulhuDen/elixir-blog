defmodule Tarantool.EctoAdapter do
  @conn __MODULE__.Conn
  @schema __MODULE__.Schema
  @schema_supervisor __MODULE__.Schema.Supervisor

  alias Tarantool.Simple, as: T

  @t %T{conn: @conn, schema: @schema}

  def start_link() do
    Supervisor.start_link(
      [
        {Tarantool.Conn, name: @conn},
        {Tarantool.Schema, name: @schema, conn: @conn, supervisor: @schema_supervisor},
        {Task.Supervisor, name: @schema_supervisor}
      ],
      strategy: :one_for_one
    )
  end

  @behaviour Ecto.Adapter

  defmacro __before_compile__(_env) do
  end

  def checkout(_adapter, _config, fun) do
    fun.()
  end

  def dumpers(:atom, type), do: [type, &Atom.to_string/1]
  def dumpers(:binary_id, type), do: [type, Ecto.UUID]
  def dumpers(_primitive, type), do: [type]

  def ensure_all_started(_config, _type), do: {:ok, []}

  def init(_config) do
    {:ok,
     %{
       id: __MODULE__,
       start: {__MODULE__, :start_link, []}
     }, %{}}
  end

  def loaders(:atom, type), do: [&String.to_atom/1, type]
  def loaders(:binary_id, type), do: [Ecto.UUID, type]
  def loaders(_primitive, type), do: [type]

  @behaviour Ecto.Adapter.Schema

  def autogenerate(:id), do: nil

  def autogenerate(type),
    do: raise("Does not support autogenerated IDs of type #{inspect(type)}")

  def delete(_adapter, schema, filters, _options) do
    case T.delete!(@t, schema.source, :primary, Enum.map(filters, &elem(&1, 1))) do
      {:ok, []} ->
        {:error, :stale}

      {:ok, [_row]} ->
        {:ok, []}
    end
  end

  def insert(_adapter, schema, fields, _on_conflict, returning, _options) do
    model_fields = apply(schema.schema, :__schema__, [:fields])

    case T.insert!(@t, schema.source, Enum.map(model_fields, &fields[&1])) do
      {:error, 32771, msg} ->
        {:invalid, unique: msg}

      {:ok, [row]} ->
        row = Enum.zip(model_fields, row)
        {:ok, Enum.map(returning, &{&1, row[&1]})}
    end
  end

  def insert_all(_adapter, _schema, _header, _list, _on_conflict, _returning, _options),
    do: raise("#{__MODULE__}.insert_all not implemented")

  def update(_adapter, schema, fields, filters, returning, _options) do
    model_fields = apply(schema.schema, :__schema__, [:fields])

    ops =
      Enum.map(fields, fn {field, val} ->
        ["=", Enum.find_index(model_fields, &(&1 == field)), val]
      end)

    case T.update!(@t, schema.source, :primary, Enum.map(filters, &elem(&1, 1)), ops) do
      {:ok, [row]} ->
        row = Enum.zip(model_fields, row)
        {:ok, Enum.map(returning, &{&1, row[&1]})}
    end
  end

  @behaviour Ecto.Adapter.Queryable

  def execute(_adapter, _query, _cache, _params, _options) do
    raise "#{__MODULE__}.execute not implemented"
  end

  def prepare(:all, query) do
    IO.inspect(query: query)
    raise "TODO"
  end

  def prepare(what, _query) do
    raise "#{__MODULE__}.prepare not implemented for #{inspect(what)}"
  end

  def stream(_adapter, _query, _cache, _params, _options) do
    raise "#{__MODULE__}.stream not implemented"
  end
end
