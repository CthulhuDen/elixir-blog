defmodule Tarantool.EctoAdapter do
  @conn __MODULE__.Conn
  @schema __MODULE__.Schema
  @schema_supervisor __MODULE__.Schema.Supervisor

  alias Tarantool.Simple, as: T

  @t %T{conn: @conn, schema: @schema}

  def start_link() do
    Supervisor.start_link(
      [
        {Tarantool.Conn, name: @conn},
        {Tarantool.Schema, name: @schema, conn: @conn, supervisor: @schema_supervisor},
        {Task.Supervisor, name: @schema_supervisor}
      ],
      strategy: :one_for_one
    )
  end

  @behaviour Ecto.Adapter

  defmacro __before_compile__(_env) do
  end

  def checkout(_adapter, _config, fun) do
    fun.()
  end

  def dumpers(:atom, type), do: [type, &Atom.to_string/1]
  def dumpers(:binary_id, type), do: [type, Ecto.UUID]
  def dumpers(_primitive, type), do: [type]

  def ensure_all_started(_config, _type), do: {:ok, []}

  def init(_config) do
    {:ok,
     %{
       id: __MODULE__,
       start: {__MODULE__, :start_link, []}
     }, %{}}
  end

  def loaders(:atom, type), do: [&String.to_atom/1, type]
  def loaders(:binary_id, type), do: [Ecto.UUID, type]
  def loaders(_primitive, type), do: [type]

  @behaviour Ecto.Adapter.Schema

  def autogenerate(:id), do: nil

  def autogenerate(type),
    do: raise("Does not support autogenerated IDs of type #{inspect(type)}")

  def delete(_adapter, schema, filters, _options) do
    case T.delete!(@t, schema.source, :primary, Enum.map(filters, &elem(&1, 1))) do
      {:ok, []} ->
        {:error, :stale}

      {:ok, [_row]} ->
        {:ok, []}
    end
  end

  def insert(_adapter, schema, fields, _on_conflict, returning, _options) do
    model_fields = apply(schema.schema, :__schema__, [:fields])

    case T.insert!(@t, schema.source, Enum.map(model_fields, &fields[&1])) do
      {:error, 32771, msg} ->
        {:invalid, unique: msg}

      {:ok, [row]} ->
        row = Enum.zip(model_fields, row)
        {:ok, Enum.map(returning, &{&1, row[&1]})}
    end
  end

  def insert_all(_adapter, _schema, _header, _list, _on_conflict, _returning, _options),
    do: raise("#{__MODULE__}.insert_all not implemented")

  def update(_adapter, schema, fields, filters, returning, _options) do
    model_fields = apply(schema.schema, :__schema__, [:fields])

    ops =
      Enum.map(fields, fn {field, val} ->
        ["=", Enum.find_index(model_fields, &(&1 == field)), val]
      end)

    case T.update!(@t, schema.source, :primary, Enum.map(filters, &elem(&1, 1)), ops) do
      {:ok, [row]} ->
        row = Enum.zip(model_fields, row)
        {:ok, Enum.map(returning, &{&1, row[&1]})}
    end
  end

  @behaviour Ecto.Adapter.Queryable

  def execute(_adapter, _query, {:cache, _fun, q}, params, _options) do
    # IO.inspect(adapter: _adapter, _query: query, cache: q, params: params, options: _options)

    {ix, key, iter} =
      case q.filter do
        {iter, ix, key} -> {ix, Enum.map(key, &replace_param(&1, params)), iter}
        {} -> {:primary, [], nil}
      end

    case Tarantool.Simple.select!(@t, q.space, ix, key,
           iterator: iter,
           limit: q.limit || 9999,
           offset: q.offset || 0
         ) do
      {:ok, rows} -> {length(rows), rows}
    end
  end

  def prepare(
        :all,
        %{
          from: %{source: {space, module}},
          select: %{expr: expr},
          wheres: wheres,
          limit: limit,
          offset: offset
        } = _query
      ) do
    # IO.inspect(query, structs: false)

    if module == nil do
      raise "Cannot select without model (directly from space)"
    end

    case expr do
      {:&, [], [0]} -> {}
      _ -> raise "Select expr not understood: #{inspect(expr)}"
    end

    filter =
      case wheres do
        [] ->
          {}

        [%{expr: {op, [], [{{:., [], [{:&, [], [0]}, field]}, [], []}, val]}}] ->
          {op_to_iter(op), field_to_ix(field, module), [val]}

        _ ->
          raise "Multi-where expressions not supported"
      end

    {:cache,
     %{
       space: space,
       module: module,
       limit: unwrap_expr(limit),
       offset: unwrap_expr(offset),
       filter: filter
     }}
  end

  def stream(_adapter, _query, _cache, _params, _options) do
    raise "#{__MODULE__}.stream not implemented"
  end

  defp unwrap_expr(nil), do: nil
  defp unwrap_expr(%{expr: expr}), do: expr
  # defp unwrap_expr(expr), do: expr

  defp op_to_iter(:==), do: Tarantool.Simple.iterator_eq()
  defp op_to_iter(:<=), do: Tarantool.Simple.iterator_le()
  defp op_to_iter(:<), do: Tarantool.Simple.iterator_lt()
  defp op_to_iter(:>=), do: Tarantool.Simple.iterator_ge()
  defp op_to_iter(:>), do: Tarantool.Simple.iterator_gt()

  defp field_to_ix(field, module) do
    if apply(module, :__schema__, [:primary_key]) == [field] do
      :primary
    else
      field
    end
  end

  defp replace_param({:^, [], [ix]}, params), do: Enum.at(params, ix)
  defp replace_param(val, _params), do: val
end
